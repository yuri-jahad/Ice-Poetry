import type { CreateUserRequest } from '@auth/auth.types'
import type { USERS } from '@database/database.types'
import { insertUserFixed } from '@auth/auth.repositories'
import { v2 as cloudinary } from 'cloudinary'

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
})

export async function createUser (
  userData: CreateUserRequest
): Promise<USERS | null> {
  try {
    const hashedPassword = await Bun.password.hash(userData.password, {
      algorithm: 'bcrypt',
      cost: 12
    })
    const userToInsert: Omit<USERS, 'id'> = {
      username: userData.username,
      password: hashedPassword,
      role: userData.role,
      image_path: userData.image_path || null
    }

    const newUser = await insertUserFixed(userToInsert)
    return newUser
  } catch (error) {
    console.error('Error creating user:', error)
    return null
  }
}

export class AvatarService {
  private static uploadCount = 0
  private static monthlyReset = new Date().getMonth()
  private static readonly MONTHLY_LIMIT = 500

  /**
   * üìä R√©cup√®re le vrai usage depuis l'API Cloudinary
   */
  private static async getRealUploadCount (): Promise<number> {
    try {
      const usage = await cloudinary.api.usage()
      // Utilisez la m√©trique appropri√©e selon votre plan Cloudinary
      const count = usage.resources || usage.transformations || 0

      // S'assurer que c'est bien un nombre
      const numericCount = Number(count)
      return isNaN(numericCount) ? this.uploadCount : numericCount
    } catch (error) {
      console.warn('‚ö†Ô∏è Cannot fetch real usage from Cloudinary:', error)
      return this.uploadCount // fallback sur le compteur local
    }
  }

  /**
   * üîç V√©rifie si une image existe d√©j√† sur Cloudinary
   */
  private static async imageExists (publicId: string): Promise<boolean> {
    try {
      await cloudinary.api.resource(`avatars/${publicId}`)
      return true
    } catch (error: any) {
      if (error.error?.http_code === 404) {
        return false // Image n'existe pas
      }
      // Autre erreur - on assume qu'elle n'existe pas pour √©viter les blocages
      console.warn(`‚ö†Ô∏è Error checking image existence: ${error.message}`)
      return false
    }
  }

  /**
   * ‚úÖ V√©rification hybride des limites mensuelles
   */
  static async canUpload (): Promise<boolean> {
    const currentMonth = new Date().getMonth()

    // Reset du compteur chaque mois
    if (currentMonth !== this.monthlyReset) {
      this.uploadCount = 0
      this.monthlyReset = currentMonth
      console.log('üîÑ Monthly counter reset')
    }

    try {
      // V√©rification hybride : API Cloudinary + compteur local
      const realUsage = await this.getRealUploadCount()
      console.log(
        `üìä Real Cloudinary usage: ${realUsage}/${this.MONTHLY_LIMIT}`
      )
      console.log(`üìä Local counter: ${this.uploadCount}/${this.MONTHLY_LIMIT}`)

      return realUsage < this.MONTHLY_LIMIT
    } catch (error) {
      console.warn('‚ö†Ô∏è Fallback to local counter due to API error')
      return this.uploadCount < this.MONTHLY_LIMIT
    }
  }

  /**
   * üì§ Upload optimis√© avec overwrite forc√© et gestion intelligente des cr√©dits
   */
  static async uploadAvatar (userId: number, file: Buffer, mimeType: string) {
    console.log(`üîÑ Attempting to upload avatar for user ${userId}`)

    // üîç V√©rifications des variables d'environnement
    if (!process.env.CLOUDINARY_CLOUD_NAME) {
      throw new Error('CLOUDINARY_CLOUD_NAME not configured in .env file')
    }
    if (!process.env.CLOUDINARY_API_KEY) {
      throw new Error('CLOUDINARY_API_KEY not configured in .env file')
    }
    if (!process.env.CLOUDINARY_API_SECRET) {
      throw new Error('CLOUDINARY_API_SECRET not configured in .env file')
    }

    // üìä V√©rification hybride des limites
    const canUploadResult = await this.canUpload()
    if (!canUploadResult) {
      throw new Error(
        'Monthly upload limit reached. Please try again next month.'
      )
    }

    const base64File = `data:${mimeType};base64,${file.toString('base64')}`

    try {
      // üî• PUBLIC_ID FIXE pour garantir l'overwrite
      const publicId = `user_${userId}` // ‚Üê PAS de timestamp !

      console.log(
        `üóÇÔ∏è Using fixed public_id: ${publicId} (will overwrite existing)`
      )
      console.log('üîë Cloudinary config:', {
        cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
        api_key: process.env.CLOUDINARY_API_KEY
          ? `${process.env.CLOUDINARY_API_KEY.substring(0, 6)}...`
          : 'MISSING',
        api_secret: process.env.CLOUDINARY_API_SECRET ? 'SET' : 'MISSING'
      })

      // üîç V√©rifier si l'image existe d√©j√† pour d√©terminer si c'est un overwrite
      const isOverwrite = await this.imageExists(publicId)

      if (isOverwrite) {
        console.log(
          `‚ôªÔ∏è Image exists - this will be an overwrite (no additional credit)`
        )
      } else {
        console.log(`‚ûï New image - will consume 1 credit`)
      }

      const uploadResult = await cloudinary.uploader.upload(base64File, {
        folder: 'avatars',
        public_id: publicId, // ‚Üê Toujours le m√™me = overwrite automatique
        transformation: [
          {
            width: 200,
            height: 200,
            crop: 'fill',
            gravity: 'face',
            quality: 80, // Optimis√© pour la taille et la qualit√©
            format: 'webp' // Format moderne plus l√©ger
          }
        ],
        overwrite: true,
        invalidate: true,
        resource_type: 'image'
      })

      // üìà Mise √† jour du compteur local seulement si nouvelle image
      if (!isOverwrite) {
        this.uploadCount++
        console.log(
          `üìà New upload counted. Local count: ${this.uploadCount}/${this.MONTHLY_LIMIT}`
        )
      } else {
        console.log(
          `‚ôªÔ∏è Overwrite - no credit consumed. Local count remains: ${this.uploadCount}/${this.MONTHLY_LIMIT}`
        )
      }

      console.log(
        `‚úÖ Avatar ${
          isOverwrite ? 'replaced' : 'uploaded'
        } successfully for user ${userId}`
      )
      console.log(`üìä Upload result:`, uploadResult.secure_url)

      // üìä Afficher le vrai usage apr√®s upload
      try {
        const realUsageAfter = await this.getRealUploadCount()
        console.log(
          `üìä Real Cloudinary usage after upload: ${realUsageAfter}/${this.MONTHLY_LIMIT}`
        )
      } catch (error) {
        console.log(
          `üìä Local count after upload: ${this.uploadCount}/${this.MONTHLY_LIMIT}`
        )
      }

      return uploadResult
    } catch (error: any) {
      console.error('‚ùå Cloudinary upload error:', error)

      if (error.message?.includes('api_key')) {
        throw new Error(
          'Cloudinary API key is missing or invalid. Check your .env configuration.'
        )
      }
      if (
        error.message?.includes('quota') ||
        error.message?.includes('credits') ||
        error.message?.includes('limit')
      ) {
        throw new Error(
          'Monthly upload limit reached on Cloudinary. Please try again next month.'
        )
      }

      throw new Error(`Upload failed: ${error.message || 'Unknown error'}`)
    }
  }

  /**
   * üñºÔ∏è G√©n√©ration d'URLs optimis√©es
   */
  static getAvatarUrl (
    userId: number,
    size: 'small' | 'medium' | 'large' = 'large'
  ): string {
    const sizes = {
      small: { width: 50, height: 50 },
      medium: { width: 100, height: 100 },
      large: { width: 200, height: 200 }
    }

    return cloudinary.url(`avatars/user_${userId}`, {
      ...sizes[size],
      crop: 'fill',
      gravity: 'face',
      quality: 80,
      format: 'webp',
      secure: true,
      // Fallback vers avatar par d√©faut si pas d'image
      flags: 'fallback_image',
      default_image: 'default-avatar.png'
    })
  }

  /**
   * üìä Statistiques d'utilisation pour monitoring (version am√©lior√©e)
   */
  static async getUsageStats () {
    try {
      const realUsage = await this.getRealUploadCount()
      const cloudinaryUsage = await cloudinary.api.usage()

      // S'assurer que tous les nombres sont valides
      const safeRealUsage = Number(realUsage) || 0
      const safeLocalCount = Number(this.uploadCount) || 0

      return {
        uploadsThisMonth: safeRealUsage,
        localCount: safeLocalCount,
        remainingUploads: Math.max(0, this.MONTHLY_LIMIT - safeRealUsage),
        percentageUsed: Math.round((safeRealUsage / this.MONTHLY_LIMIT) * 100),
        resetDate: new Date(
          new Date().getFullYear(),
          new Date().getMonth() + 1,
          1
        ).toISOString(),
        isNearLimit: safeRealUsage > 400,
        cloudinaryData: {
          resources: Number(cloudinaryUsage.resources) || 0,
          transformations: Number(cloudinaryUsage.transformations) || 0,
          storage: Number(cloudinaryUsage.storage) || 0
        }
      }
    } catch (error) {
      // Fallback en cas d'erreur API - s'assurer que tous sont des nombres
      const safeLocalCount = Number(this.uploadCount) || 0

      return {
        uploadsThisMonth: safeLocalCount,
        localCount: safeLocalCount,
        remainingUploads: Math.max(0, this.MONTHLY_LIMIT - safeLocalCount),
        percentageUsed: Math.round((safeLocalCount / this.MONTHLY_LIMIT) * 100),
        resetDate: new Date(
          new Date().getFullYear(),
          new Date().getMonth() + 1,
          1
        ).toISOString(),
        isNearLimit: safeLocalCount > 400,
        error: 'Could not fetch Cloudinary usage data'
      }
    }
  }

  /**
   * üîç V√©rification si un avatar existe
   */
  static async avatarExists (userId: number): Promise<boolean> {
    return await this.imageExists(`user_${userId}`)
  }

  /**
   * üóëÔ∏è M√©thode pour supprimer un avatar
   */
  static async deleteAvatar (userId: number): Promise<boolean> {
    try {
      console.log(`üóëÔ∏è Attempting to delete avatar for user ${userId}`)

      const result = await cloudinary.uploader.destroy(`avatars/user_${userId}`)

      if (result.result === 'ok') {
        console.log(`‚úÖ Avatar deleted for user ${userId}`)

        // Afficher l'usage apr√®s suppression
        try {
          const realUsage = await this.getRealUploadCount()
          console.log(
            `üìä Usage after deletion: ${realUsage}/${this.MONTHLY_LIMIT}`
          )
        } catch (error) {
          console.log(
            `üìä Local count: ${this.uploadCount}/${this.MONTHLY_LIMIT}`
          )
        }

        return true
      } else {
        console.log(`‚ö†Ô∏è Avatar not found or already deleted for user ${userId}`)
        return false
      }
    } catch (error) {
      console.error(`‚ùå Error deleting avatar for user ${userId}:`, error)
      return false
    }
  }

  /**
   * üîÑ Reset manuel du compteur local (pour debug/maintenance)
   */
  static resetLocalCounter () {
    this.uploadCount = 0
    console.log('üîÑ Local upload counter reset to 0')
  }
}
